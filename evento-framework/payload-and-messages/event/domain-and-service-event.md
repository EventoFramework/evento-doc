# Domain and Service Event

In Evento Framework, event-driven communication hinges on two crucial types of events: Domain Events and Service Events. These categories differentiate the origin and purpose of the events within your system. Understanding these distinctions is essential for building a well-structured and maintainable event-driven architecture.

While both Domain Events and Service Events leverage the core `Event` class and its functionalities in Evento Framework, they might utilize more specific payload structures for their data. Since Domain Events and Service Events cater to different purposes within your application, it's common to define concrete event classes that inherit from `DomainEvent` or `ServiceEvent` respectively. These concrete event classes can then have their own data members specific to the information they need to convey. This approach promotes better organization and clarity, as the event payload structure directly reflects the type of event (domain or service) and the data relevant to that particular event type. For instance, a `ProductPurchasedEvent` (Domain Event) might contain product details and quantity changes, while a `PaymentProcessingFailedEvent` (Service Event) might focus on error codes and payment information specific to the service interaction.

```java
package com.evento.common.modeling.messaging.payload;

/**
 * The DomainEvent class represents an abstract base class for domain events.
 * <p>
 * It extends the Event class.
 *
 * @see Event
 */
public abstract class DomainEvent extends Event {
}
```

```java
package com.evento.common.modeling.messaging.payload;

/**
 * The ServiceEvent class represents an abstract base class for service events.
 * It extends the Event class.
 *
 * @see Event
 */
public abstract class ServiceEvent extends Event {
}
```

#### Domain Events: Echoes of Domain Changes

Domain Events represent the core building blocks of event-driven communication within your domain model. They act as a consequence of actions triggered by Domain Commands:

* **Source:** Domain Events originate from aggregates, the heart of your domain logic.
* **Trigger:** They are typically generated when a Domain Command is processed by an aggregate, reflecting a state change within the domain.
* **Purpose:** Domain Events encapsulate information about the domain object's state change. This information can be used for various purposes, including:
  * Updating read models to ensure consistency between the domain state and how it's presented in different contexts (e.g., UIs, reports).
  * Triggering workflows or processes that depend on domain state changes.
  * Implementing eventual consistency patterns across different parts of your system.

**Benefits of Domain Events:**

* **Decoupling:** Domain Events promote loose coupling between different parts of your system. Services and other components can subscribe to domain events without needing tight integration with the domain logic itself.
* **Auditability:** Domain Events provide an immutable record of changes within your domain, facilitating easier auditing and debugging.
* **Real-time Updates:** By subscribing to domain events, downstream components can react to domain changes in near real-time, enabling reactive applications.

**Code Sample: Domain Event**

```java
public class OrderPlacedEvent extends DomainEvent {

    private String orderId;
    private List<String> productIds;
    private int totalQuantity;

    // Getters and setters for the event data (orderId, productIds, totalQuantity)

    public OrderPlacedEvent(String orderId, List<String> productIds, int totalQuantity) {
        this.orderId = orderId;
        this.productIds = productIds;
        this.totalQuantity = totalQuantity;
    }
}
```

In this example, `OrderPlacedEvent` is a domain event generated when an order is placed within the domain model. It contains information about the order ID, product IDs involved, and total quantity.

#### Service Events: Messages from the Service Layer

Service Events, on the other hand, originate from services within your architecture:

* **Source:** These events are generated by service components in response to various service-related activities.
* **Trigger:** The specific triggers for service events can vary depending on the service implementation. Examples include:
  * Completing a long-running task within a service.
  * Detecting an error condition during service execution.
  * Successfully processing an external request by the service.
* **Purpose:** Service Events serve diverse purposes depending on the service's functionality. They might be used for:
  * Notifying other components about service state changes or completion of tasks.
  * Triggering workflows or processes that depend on service outputs.
  * Coordinating communication between different services within your architecture.

**Benefits of Service Events:**

* **Asynchronous Communication:** Service Events facilitate asynchronous communication between services, improving scalability and decoupling.
* **Resilience:** By leveraging event-driven communication, services can be more resilient to failures, as other components can react to events even if the originating service is unavailable momentarily.
* **Loose Coupling:** Similar to Domain Events, service events promote loose coupling between services, improving maintainability and flexibility.

**Code Sample: Service Event**

```java
public class PaymentProcessingCompletedEvent extends ServiceEvent {

    private String paymentId;
    private String orderId;
    private boolean success;

    // Getters and setters for the event data (paymentId, orderId, success)

    public PaymentProcessingCompletedEvent(String paymentId, String orderId, boolean success) {
        this.paymentId = paymentId;
        this.orderId = orderId;
        this.success = success;
    }
}
```

This example shows a `PaymentProcessingCompletedEvent` as a service event. It's generated by a payment processing service to notify other components about the completion of a payment and whether it was successful (identified by the `success` flag).

#### Key Differences and Use Cases

Here's a table summarizing the key differences between Domain Events and Service Events:

| Feature   | Domain Event                                                     | Service Event                                                    |
| --------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| Source    | Aggregates within the domain model                               | Services within the architecture                                 |
| Trigger   | Processing a Domain Command                                      | Service-specific activities (tasks, errors, completions)         |
| Purpose   | Reflect state changes within the domain                          | Communicate service state changes or trigger workflows           |
| Use Cases | Updating read models, triggering workflows, eventual consistency | Notifying other components, service coordination, error handling |

**Example:**

* Imagine an e-commerce application. A `ProductPurchasedEvent` (Domain Event) might be generated when an order is placed, reflecting the change in product quantity within the domain model.
* On the other hand, a `PaymentProcessingCompletedEvent` (Service Event) might be triggered by a payment processing service to notify other components that the payment for the order has been successful.

#### Conclusion

By understanding the distinctions between Domain Events and Service Events, you can effectively leverage event-driven communication within your Evento Framework applications. Domain Events keep your domain model loosely coupled and facilitate consistency updates, while Service Events enable communication and coordination between different services within your architecture. By strategically utilizing both types of events, you can build a robust and scalable event-driven system.
